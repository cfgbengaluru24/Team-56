{
  "version": 3,
  "sources": ["../../node_modules/initials/lib/initials.js", "../../node_modules/initials/index.js", "../../node_modules/@dicebear/avatars-initials-sprites/dist/index.es.js"],
  "sourcesContent": ["module.exports = initials\n\n// extend public API\ninitials.addTo = addInitialsTo\ninitials.parse = parse\ninitials.find = initials\n\n// defaults\nvar defaultLength = 2\n\n// there is no support for look-behinds in JS, and the \\b selector\n// doesn't work with diacritics. So we maintain a blacklist of\n// \"non letters\", that we use later to build our regex.\nvar nonLetters = ' -\\\\/:-@\\\\[-`\\\\{-\\\\~'\n// regex patterns\nvar uppercaseLettersOnlyPattern = /^[A-Z]+$/\nvar initialsInNamePattern = /\\(([^)]+)\\)/\nvar nameIsEmailPattern = /^[^\\s]+@[^\\s]+$/\nvar findDomainInEmailPattern = /@[^\\s]+/\nvar findEmailPattern = /[\\w._-]+@[\\w.-]+[\\w]/g\n\n// match everything that is a \"non letter\" (see above)\n// followed by all but a \"non letter\".\n// Expl: \"Jörg Jäger-Franke\" => [\"J\", \" J\", \"-F\"]\nvar findFirstLettersOfWordsPattern = new RegExp('(^|[' + nonLetters + '])[^' + nonLetters + ']', 'g')\nvar findAllNonCharactersPattern = new RegExp('[' + nonLetters + ']', 'g')\n\n// PUBLIC API METHODS\n\n//\n// initials allows to be used with either a string or an array of strings\n//\nfunction initials (nameOrNames, options) {\n  if (!nameOrNames) return ''\n  if (typeof nameOrNames === 'string') return initialsForSingleName(nameOrNames, normalize(options))\n  return initialsForMultipleNames(nameOrNames, normalize(options))\n}\n\n//\n// finds initials in a name and adds them to the right side\n//\nfunction addInitialsTo (nameOrNames, options) {\n  if (!nameOrNames) return ''\n  if (typeof nameOrNames === 'string') return addInitialsToSingleName(nameOrNames, normalize(options))\n  return addInitialsToMultipleNames(nameOrNames, normalize(options))\n}\n\n//\n// extract name, initials, email\n//\nfunction parse (nameOrNames, options) {\n  if (!nameOrNames) return {}\n  if (typeof nameOrNames === 'string') return parseSingleName(nameOrNames, normalize(options))\n  return parseMultipleNames(nameOrNames, normalize(options))\n}\n\n// HELPER METHODS\n\n//\n// Find initials in a single given name string\n//\nfunction initialsForSingleName (name, options) {\n  var matches\n  var result\n  var initials\n  var length = options.length || 2\n\n  initials = findPreferredInitials(name, options)\n  if (initials) return initials\n\n  name = cleanupName(name)\n  if (!name) return ''\n\n  // there is no support for look-behinds in JS, and the \\b selector\n  // doesn't work with diacritics. So we match everything that is a\n  // \"non character\" followed by all but a \"non character\". To fix\n  // that, we map the results to its last character.\n  // Expl: \"Jörg Jäger\" => [\"J\", \" J\"] => [\"J\", \"J\"]\n  matches = name.match(findFirstLettersOfWordsPattern).map(function (match) {\n    return match[match.length - 1]\n  })\n\n  if (matches.length < 2) {\n    if (name.length > length) {\n      return name.substr(0, length)\n    } else {\n      return name\n    }\n  } else {\n    result = matches.join('')\n  }\n\n  if (result.length >= length) {\n    return result\n  }\n\n  // This is where it gets complicated.\n  // Let's say we're in initials('John Doe', 3), so up to here\n  // we have `result === 'JD'`, but what we want is `result === `JDo`.\n\n  // First, we calculate all remaining options that we have\n  var possibleInitials = getPossibleInitialsForName(name)\n  var option\n\n  // then we return the first option that has the required length\n  for (var i = 0; i < possibleInitials.length; i++) {\n    if (possibleInitials[i].length >= length) return possibleInitials[i]\n  };\n\n  // if that didn't work, we return the last possible option\n  return option\n}\n\n//\n//\n//\nfunction initialsForMultipleNames (names, options) {\n  var optionsForNames = []\n  var optionsCountForNames\n  var map = {}\n  var duplicatesMap = {}\n  var initialsForNamesMap = {}\n  var initials\n  var possibleInitials\n  var length = options.length || 2\n\n  // get all possible initials for all names for given length\n  names.forEach(function (name) {\n    // normalize\n    if (!name) name = ''\n\n    // known name? Gets same initials, stop here\n    if (initialsForNamesMap[name]) return\n\n    // too short to extract initials from? Use name as initials.\n    if (name.length < length) {\n      initialsForNamesMap[name] = [name]\n      return\n    }\n\n    // preferred initials like (JD)? Use these\n    initials = findPreferredInitials(name, options)\n    if (initials) {\n      map[initials] = 1\n      initialsForNamesMap[name] = [initials]\n      return\n    }\n\n    // return all possible initials for given length\n    possibleInitials = getPossibleInitialsForName(name).filter(function (initials) {\n      if (initials.length !== length) return false\n      if (map[initials]) duplicatesMap[initials] = 1\n      map[initials] = 1\n      return true\n    })\n\n    initialsForNamesMap[name] = possibleInitials\n  })\n\n  // remove duplicates\n  var keys = []\n  for (var k in initialsForNamesMap) {\n    keys.unshift(k)\n  }\n  for (var c = keys.length, n = 0; n < c; n++) {\n    possibleInitials = initialsForNamesMap[keys[n]]\n    optionsForNames.push(possibleInitials)\n\n    for (var i = 0; i < possibleInitials.length; i++) {\n      if (duplicatesMap[possibleInitials[i]] > 0) {\n        duplicatesMap[possibleInitials[i]]--\n        possibleInitials.splice(i, 1)\n      }\n    }\n  }\n\n  // make sure we still have options for every name\n  optionsCountForNames = optionsForNames.map(function (options) { return options.length })\n\n  // if names were empty, optionsCountForNames is empty. In that case stop here\n  if (optionsCountForNames.length === 0) return names\n\n  if (Math.min.apply(null, optionsCountForNames) === 0) {\n    options.length++\n    return initialsForMultipleNames(names, options)\n  }\n\n  // if we do, return the first option for each\n  return names.map(function (name) { return initialsForNamesMap[name][0] })\n}\n\n//\n//\n//\nfunction addInitialsToSingleName (name, options) {\n  var parts = parseSingleName(name, options)\n  return format(parts)\n}\n\n//\n//\n//\nfunction addInitialsToMultipleNames (names, options) {\n  return parseMultipleNames(names, options).map(format)\n}\n\n//\n//\n//\nfunction parseSingleName (name, options) {\n  var initials\n  var email\n  var matches\n  var parts = {}\n\n  if (!name) return {}\n\n  // are initials part of the name?\n  initials = findPreferredInitials(name, options)\n  if (initials) {\n    // if yes, remove it from name\n    name = name.replace(uppercaseLettersOnlyPattern, '')\n    name = name.replace(initialsInNamePattern, '')\n  }\n\n  // use preferred initials if passed\n  if (options.initials) initials = options.initials\n\n  // if no initials found yet, extract initials from name\n  if (!initials) initials = initialsForSingleName(name, options)\n\n  // is there an email in the name?\n  matches = name.match(findEmailPattern)\n  if (matches != null) email = matches.pop()\n  if (email) {\n    // if yes, remove it from name\n    name = name.replace(email, '')\n\n    // if the email and the name are the same, initials can not be rendered\n    // the initials method uses email for rendering just when the name is false\n    // see https://github.com/gr2m/initials/issues/7 for more details\n    if (name.trim() === '<' + email + '>') {\n      // set the name to undefined\n      name = ''\n\n      // fire up the initials again with the email\n      if (!initials) {\n        initials = initialsForSingleName(email, options)\n      }\n    }\n  }\n\n  // clean up the rest\n  name = name.replace(findAllNonCharactersPattern, ' ').trim()\n\n  // do only return what's present\n  if (name) parts.name = name\n  if (initials) parts.initials = initials\n  if (email) parts.email = email\n\n  return parts\n}\n\n//\n//\n//\nfunction parseMultipleNames (names, options) {\n  var initialsArray = initialsForMultipleNames(names, options)\n\n  return names.map(function (name, i) {\n    options.existing[name] = initialsArray[i]\n    return parseSingleName(name, options)\n  })\n}\n\n//\n//\n//\nfunction format (parts) {\n  // neither name nor email: return initials\n  if (!parts.name && !parts.email) return parts.initials\n\n  // no email: return name with initials\n  if (!parts.email) return parts.name + ' (' + parts.initials + ')'\n\n  // no name: return email with initials\n  if (!parts.name) return parts.email + ' (' + parts.initials + ')'\n\n  // return name with initials & name\n  return parts.name + ' (' + parts.initials + ') <' + parts.email + '>'\n}\n\n//\n//\n//\nfunction cleanupName (name) {\n  // in case the name is an email address, remove the @xx.yy part\n  // otherwise remove an eventual email address from name\n  if (nameIsEmailPattern.test(name)) {\n    name = name.replace(findDomainInEmailPattern, '')\n  } else {\n    name = name.replace(findEmailPattern, '')\n  }\n\n  // replace all non characters with ' ' & trim\n  name = name.replace(findAllNonCharactersPattern, ' ').trim()\n\n  return name\n}\n\n//\n//\n//\nfunction findPreferredInitials (name, options) {\n  var matches\n\n  // if preferred initials passed for current name\n  if (options.existing[name]) return options.existing[name]\n\n  // if the name contains only upcase letters, let's take it as the initials as well\n  if (uppercaseLettersOnlyPattern.test(name)) {\n    return name\n  }\n\n  // are the initials part of the given name, e.g. »Eddie Murphie (em)«?\n  matches = name.match(initialsInNamePattern)\n\n  // if yes, return them\n  if (matches != null) {\n    return matches.pop()\n  }\n}\n\n//\n// e.g. for John Doe:\n// - JDo\n// - JDoe\n// - JoDoe\n// - JohDoe\n// - JohnDoe\n//\nvar cache = {}\nfunction getPossibleInitialsForName (name) {\n  var parts\n  var partsPossibilities\n  var options = []\n\n  name = cleanupName(name)\n\n  if (cache[name]) {\n    return cache[name].slice(0) // return copy\n  }\n\n  // split names into parts\n  // 'John Doe' => ['Doe', 'John']\n  parts = name.split(' ')\n\n  // map parts to all its possible initials\n  // 'John' => ['J', 'Jo', 'Joh', 'John']\n  partsPossibilities = parts.map(getPossibleInitialsForWord)\n\n  options = combineAll(partsPossibilities)\n\n  // sort options, shortest first\n  options = options.sort(function (a, b) {\n    return a.length - b.length || options.indexOf(a) - options.indexOf(b)\n  })\n\n  // cache for future\n  cache[name] = options\n\n  // return options\n  return options.slice(0)\n}\n\n//\n//\n//\nfunction combineAll (array) {\n  var current = array.shift()\n  var temp\n  var results\n  if (array.length > 0) {\n    results = []\n    temp = combineAll(array)\n    current.forEach(function (value1) {\n      temp.forEach(function (value2) {\n        results.push(value1 + value2)\n      })\n    })\n    return results\n  } else {\n    return current\n  }\n}\n\n//\n//\n//\nfunction getPossibleInitialsForWord (word) {\n  var options = []\n  while (word.length) {\n    options.unshift(word)\n    word = word.substr(0, word.length - 1)\n  }\n  return options\n}\n\n//\n// make sure that options is always an object, and that\n// * options.length is a number and >= defaultLength\n// * existing is set and an object\n//\nfunction normalize (options) {\n  if (!options) options = { length: defaultLength }\n  if (typeof options === 'number') options = { length: options }\n\n  options.length = Math.max(options.length || 0, defaultLength)\n  options.existing = options.existing || {}\n\n  return options\n}\n", "module.exports = require('./lib/initials')\n", "import legacy, { utils } from '@dicebear/avatars';\nimport initials from 'initials';\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar schema$1 = {\n  \"title\": \"Options\",\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"properties\": {\n    \"backgroundColors\": {\n      \"title\": \"Background Colors\",\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"string\",\n        \"enum\": [\"amber\", \"blue\", \"blueGrey\", \"brown\", \"cyan\", \"deepOrange\", \"deepPurple\", \"green\", \"grey\", \"indigo\", \"lightBlue\", \"lightGreen\", \"lime\", \"orange\", \"pink\", \"purple\", \"red\", \"teal\", \"yellow\"]\n      }\n    },\n    \"backgroundColorLevel\": {\n      \"title\": \"Background Color Level\",\n      \"default\": 600,\n      \"type\": \"integer\",\n      \"enum\": [50, 100, 200, 300, 400, 500, 600, 700, 800, 900]\n    },\n    \"fontSize\": {\n      \"title\": \"Font Size\",\n      \"type\": \"integer\",\n      \"minimum\": 1,\n      \"maximum\": 100,\n      \"default\": 50\n    },\n    \"chars\": {\n      \"title\": \"Chars\",\n      \"type\": \"number\",\n      \"minimum\": 0,\n      \"maximum\": 2,\n      \"default\": 2\n    },\n    \"bold\": {\n      \"title\": \"Bold\",\n      \"type\": \"boolean\"\n    }\n  },\n  \"additionalProperties\": false\n};\n\nvar style = {\n  meta: {\n    title: 'Initials',\n    creator: 'Florian Körner',\n    source: 'https://github.com/dicebear/dicebear',\n    license: {\n      name: 'CC0 1.0',\n      url: 'https://creativecommons.org/publicdomain/zero/1.0/'\n    }\n  },\n  schema: schema$1,\n  create: function create(_ref) {\n    var _options$chars, _options$fontSize;\n\n    var prng = _ref.prng,\n        options = _ref.options;\n    var defaults = utils.schema.defaults(schema$1);\n    var backgroundColors = [];\n\n    if (options.background) {\n      if (Array.isArray(options.background)) {\n        backgroundColors.push.apply(backgroundColors, _toConsumableArray(options.background));\n      } else {\n        backgroundColors.push(options.background);\n      }\n\n      options.background = undefined;\n    } else {\n      Object.keys(legacy.color.collection).forEach(function (backgroundColor) {\n        if (options.backgroundColors === undefined || options.backgroundColors.length === 0 || options.backgroundColors.indexOf(backgroundColor) !== -1) {\n          var _options$backgroundCo;\n\n          var colorCollection = legacy.color.collection[backgroundColor];\n          backgroundColors.push(colorCollection[(_options$backgroundCo = options.backgroundColorLevel) !== null && _options$backgroundCo !== void 0 ? _options$backgroundCo : defaults.backgroundColorLevel]);\n        }\n      });\n    }\n\n    var backgroundColor = prng.pick(backgroundColors);\n    var seedInitials = initials(prng.seed.trim()).toLocaleUpperCase().slice(0, (_options$chars = options.chars) !== null && _options$chars !== void 0 ? _options$chars : defaults.chars);\n    var fontFamily = 'Arial,sans-serif';\n    var fontSize = ((_options$fontSize = options.fontSize) !== null && _options$fontSize !== void 0 ? _options$fontSize : defaults.fontSize) / 100; // prettier-ignore\n\n    var svg = [\"<rect width=\\\"1\\\" height=\\\"1\\\" fill=\\\"\".concat(backgroundColor, \"\\\"></rect>\"), options.margin ? \"<g transform=\\\"translate(\".concat(options.margin / 100, \", \").concat(options.margin / 100, \")\\\">\") : '', options.margin ? \"<g transform=\\\"scale(\".concat(1 - options.margin * 2 / 100, \")\\\">\") : '', \"<text x=\\\"50%\\\" y=\\\"50%\\\" style=\\\"\".concat(options.bold ? 'font-weight: bold;' : '', \" font-family: \").concat(fontFamily, \"; font-size: \").concat(fontSize, \"px\\\" fill=\\\"#FFF\\\" text-anchor=\\\"middle\\\" dy=\\\"\").concat((fontSize * .356).toFixed(3), \"\\\">\").concat(seedInitials, \"</text>\"), options.margin ? '</g>' : '', options.margin ? '</g>' : ''].join('');\n    options.margin = undefined;\n    return {\n      attributes: {\n        viewBox: '0 0 1 1'\n      },\n      body: svg\n    };\n  }\n};\n\n/*!\r\n * DiceBear Initials (@dicebear/avatars-initials-sprites)\r\n *\r\n * Code licensed under MIT (https://github.com/dicebear/dicebear/blob/v4/packages/avatars-initials-sprites/LICENSE)\r\n * Copyright (c) 2021 Florian Körner\r\n */\nvar create = style.create,\n    meta = style.meta,\n    schema = style.schema;\n/** @deprecated will be removed in Version 5.0 */\n\nvar index = utils.style.createLegacyWrapper({\n  create: create,\n  meta: meta,\n  schema: schema\n});\n\nexport { create, index as default, meta, schema };\n"],
  "mappings": "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",
  "names": ["initials", "options", "require_initials", "backgroundColor", "initials", "create", "index"]
}
